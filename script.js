// Deriv Dashboard JavaScript
document.addEventListener('DOMContentLoaded', function() {
    // Initialize Socket.IO connection
    const socket = io();
    
    // DOM Elements
    const analyzeBtn = document.getElementById('analyzeBtn');
    const simulateBtn = document.getElementById('simulateBtn');
    const refreshBtn = document.getElementById('refreshPrediction');
    const contractTypeSelect = document.getElementById('contractType');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const ticksCount = document.getElementById('ticksCount');
    const modelsStatus = document.getElementById('modelsStatus');
    const lastUpdate = document.getElementById('lastUpdate');
    const quickStats = document.getElementById('quickStats');
    const predictionResult = document.getElementById('predictionResult');
    const detailedAnalysis = document.getElementById('detailedAnalysis');
    const liveUpdateCount = document.getElementById('liveUpdateCount');
    
    let updateCounter = 0;

    // Add animated particles to background
function createParticles() {
    const particlesContainer = document.createElement('div');
    particlesContainer.className = 'gold-particles';
    document.body.appendChild(particlesContainer);
    
    for (let i = 0; i < 50; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.animationDelay = `${Math.random() * 20}s`;
        particle.style.animationDuration = `${20 + Math.random() * 20}s`;
        particlesContainer.appendChild(particle);
    }
}

// Create particles on load
createParticles();
    
    // Update contract description when changed
    contractTypeSelect.addEventListener('change', function() {
        updateContractDescription(this.value);
    });
    
   // Analyze Button Click with Animations
analyzeBtn.addEventListener('click', async function() {
    setStatus('analyzing', 'Analyzing contract...');
    analyzeBtn.disabled = true;
    analyzeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Analyzing...';
    
    // Show analyzing animation
    showAnalyzingAnimation();
    
    const contractType = contractTypeSelect.value;
    const symbol = document.getElementById('volatilityIndex').value;
    
    try {
        const response = await fetch('/api/start-analysis', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                contract_type: contractType,
                symbol: symbol
            })
        });
        
        const data = await response.json();
        
        // Hide analyzing animation
        hideAnalyzingAnimation();
        
        if (data.status === 'success') {
            // Show success animation
            showSuccessAnimation();
            
            setTimeout(() => {
                displayPrediction(data.analysis, data.prediction);
                updateStatistics(data.statistics);
                displayDetailedAnalysis(data);
                setStatus('online', 'Analysis complete');
                showNotification('success', 'Analysis completed successfully!');
            }, 1000);
            
        } else if (data.status === 'collecting') {
            showNotification('warning', data.message);
            setStatus('analyzing', data.message);
        }
    } catch (error) {
        console.error('Error:', error);
        showNotification('error', 'Failed to analyze. Please try again.');
        setStatus('offline', 'Connection error');
        hideAnalyzingAnimation();
    } finally {
        analyzeBtn.disabled = false;
        analyzeBtn.innerHTML = '<i class="fas fa-play"></i> Analyze Now';
    }
});

// Show analyzing animation
function showAnalyzingAnimation() {
    let analyzingHTML = `
        <div class="analyzing-animation active">
            <div class="neural-network" id="neuralNetwork">
                <!-- Neural network nodes will be generated by JS -->
            </div>
            <div class="loading-wave">
                <div class="loading-bar"></div>
                <div class="loading-bar"></div>
                <div class="loading-bar"></div>
                <div class="loading-bar"></div>
                <div class="loading-bar"></div>
            </div>
            <h3 style="color: var(--gold-primary); margin-top: 20px;">Analyzing Market Patterns</h3>
            <p style="color: var(--gold-light); opacity: 0.8;">Running ML algorithms on 300+ data points...</p>
        </div>
    `;
    
    predictionResult.innerHTML = analyzingHTML;
    
    // Create neural network visualization
    createNeuralNetwork();
}

// Create neural network animation
function createNeuralNetwork() {
    const container = document.getElementById('neuralNetwork');
    if (!container) return;
    
    container.innerHTML = '';
    
    // Create layers
    const layers = 5;
    const nodesPerLayer = [3, 4, 5, 4, 3];
    
    for (let layer = 0; layer < layers; layer++) {
        for (let node = 0; node < nodesPerLayer[layer]; node++) {
            const nodeElement = document.createElement('div');
            nodeElement.className = 'node';
            nodeElement.style.left = `${(layer + 1) * 50}px`;
            nodeElement.style.top = `${(node + 1) * 35}px`;
            nodeElement.style.animationDelay = `${Math.random()}s`;
            container.appendChild(nodeElement);
            
            // Create connections to next layer
            if (layer < layers - 1) {
                for (let nextNode = 0; nextNode < nodesPerLayer[layer + 1]; nextNode++) {
                    const connection = document.createElement('div');
                    connection.className = 'connection';
                    connection.style.left = `${(layer + 1) * 50 + 10}px`;
                    connection.style.top = `${(node + 1) * 35 + 10}px`;
                    connection.style.width = '40px';
                    connection.style.transform = `rotate(${Math.atan2(
                        (nextNode + 1) * 35 - (node + 1) * 35,
                        40
                    )}rad)`;
                    connection.style.animationDelay = `${Math.random()}s`;
                    container.appendChild(connection);
                }
            }
        }
    }
}

// Hide analyzing animation
function hideAnalyzingAnimation() {
    const animation = document.querySelector('.analyzing-animation');
    if (animation) {
        animation.classList.remove('active');
        setTimeout(() => {
            if (animation.parentNode) {
                animation.parentNode.removeChild(animation);
            }
        }, 300);
    }
}

// Show success animation
function showSuccessAnimation() {
    let successHTML = `
        <div class="success-animation active">
            <div class="checkmark"></div>
            <h3 style="color: var(--success); margin-top: 20px;">Analysis Complete!</h3>
            <p style="color: var(--gold-light); opacity: 0.8;">Prediction generated successfully</p>
        </div>
    `;
    
    predictionResult.innerHTML = successHTML;
}

// Hide success animation
function hideSuccessAnimation() {
    const animation = document.querySelector('.success-animation');
    if (animation) {
        animation.classList.remove('active');
        setTimeout(() => {
            if (animation.parentNode) {
                animation.parentNode.removeChild(animation);
            }
        }, 300);
    }
}
    
    // Simulate Data Button
    simulateBtn.addEventListener('click', async function() {
        simulateBtn.disabled = true;
        simulateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Simulating...';
        
        try {
            const response = await fetch('/api/simulate-data', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ count: 50 })
            });
            
            const data = await response.json();
            
            if (data.status === 'success') {
                updateDataStatus(data.total_ticks, data.is_trained);
                showNotification('success', `Added ${data.added_ticks} simulated ticks`);
                
                if (data.is_trained) {
                    showNotification('success', 'ML models trained successfully!');
                }
            }
        } catch (error) {
            console.error('Error:', error);
            showNotification('error', 'Failed to simulate data');
        } finally {
            simulateBtn.disabled = false;
            simulateBtn.innerHTML = '<i class="fas fa-bolt"></i> Simulate 50 Ticks';
        }
    });
    
    // Refresh Prediction Button
    refreshBtn.addEventListener('click', async function() {
        try {
            const response = await fetch('/api/get-prediction', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            const data = await response.json();
            
            if (data.status === 'success') {
                displayPrediction(data.analysis, data.prediction);
                updateStatistics(data.statistics);
                showNotification('info', 'Prediction refreshed');
            }
        } catch (error) {
            console.error('Error:', error);
            showNotification('error', 'Failed to refresh prediction');
        }
    });
    
    // Update contract description
    function updateContractDescription(contractType) {
        const descriptions = {
            'digit_match': 'Predict if last digit matches your choice (10% probability, 9:1 payout)',
            'digit_differs': 'Predict if last digit differs from your choice (90% probability, 0.35:1 payout)',
            'digit_over': 'Predict if last digit is over 4 (50% probability, 0.9:1 payout)',
            'digit_under': 'Predict if last digit is under 5 (50% probability, 0.9:1 payout)',
            'digit_odd': 'Predict if last digit is odd (50% probability, 0.9:1 payout)',
            'digit_even': 'Predict if last digit is even (50% probability, 0.9:1 payout)'
        };
        
        document.getElementById('contractDescription').textContent = 
            descriptions[contractType] || 'Select a contract type';
    }
    
    // Display prediction result
    function displayPrediction(analysis, prediction) {
        if (!analysis || !prediction) return;
        
        const contractInfo = {
            'digit_match': { name: 'Digit Matches', color: '#3a86ff' },
            'digit_differs': { name: 'Digit Differs', color: '#8338ec' },
            'digit_over': { name: 'Digit Over', color: '#38b000' },
            'digit_under': { name: 'Digit Under', color: '#ffbe0b' },
            'digit_odd': { name: 'Digit Odd', color: '#ff006e' },
            'digit_even': { name: 'Digit Even', color: '#fb5607' }
        };
        
        const info = contractInfo[analysis.contract_type] || contractInfo.digit_match;
        const confidencePercent = Math.round(prediction.ensemble.confidence * 100);
        
        const predictionHTML = `
            <div class="prediction-display">
                <div class="prediction-header" style="border-left: 5px solid ${info.color}">
                    <div>
                        <h3 style="color: ${info.color}">${info.name}</h3>
                        <p class="contract-desc">${analysis.recommendation}</p>
                    </div>
                    <div class="confidence-badge">
                        <span class="confidence-value">${confidencePercent}%</span>
                        <small>Confidence</small>
                    </div>
                </div>
                
                <div class="prediction-body">
                    <div class="predicted-digit">
                        <div class="digit-display">
                            <span class="digit">${analysis.predicted_digit}</span>
                            <div class="digit-label">Predicted Digit</div>
                        </div>
                        
                        <div class="prediction-details">
                            <div class="detail-item">
                                <span class="detail-label">Expected Payout:</span>
                                <span class="detail-value">${analysis.expected_payout}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Theoretical Probability:</span>
                                <span class="detail-value">${analysis.probability}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Prediction Time:</span>
                                <span class="detail-value">${new Date(analysis.prediction_time).toLocaleTimeString()}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="model-votes">
                        <h4>Model Consensus:</h4>
                        <div class="vote-bars">
                            ${Object.entries(prediction.ensemble.vote_distribution).map(([digit, count]) => `
                                <div class="vote-bar">
                                    <div class="vote-digit">${digit}</div>
                                    <div class="vote-count">${count} votes</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
                
                <div class="prediction-footer">
                    <div class="disclaimer">
                        <i class="fas fa-exclamation-circle"></i>
                        <span>This is a simulated prediction for educational purposes only</span>
                    </div>
                </div>
            </div>
        `;
        
        predictionResult.innerHTML = predictionHTML;
        
        // Update charts
        updateDigitChart(prediction.statistics);
        updateHistoryChart(prediction);
    }
    
    // Display detailed analysis
    function displayDetailedAnalysis(data) {
        const analysisHTML = `
            <div class="analysis-grid">
                <div class="analysis-section">
                    <h4><i class="fas fa-brain"></i> ML Model Performance</h4>
                    <div class="model-performance">
                        ${data.prediction ? Object.entries(data.prediction.models).map(([name, model]) => `
                            <div class="model-item">
                                <span class="model-name">${name.replace('_', ' ').toUpperCase()}</span>
                                <span class="model-confidence">${Math.round(model.confidence * 100)}%</span>
                                <span class="model-prediction">Digit: ${model.digit}</span>
                            </div>
                        `).join('') : '<p>No model data available</p>'}
                    </div>
                </div>
                
                <div class="analysis-section">
                    <h4><i class="fas fa-chart-bar"></i> Recent Statistics</h4>
                    <div class="stats-list">
                        ${data.statistics ? `
                            <div class="stat-row">
                                <span>Total Ticks:</span>
                                <span>${data.statistics.total_ticks}</span>
                            </div>
                            <div class="stat-row">
                                <span>Most Common Digit:</span>
                                <span>${data.statistics.most_common[0] ? `${data.statistics.most_common[0][0]} (${data.statistics.most_common[0][1]}x)` : 'N/A'}</span>
                            </div>
                            <div class="stat-row">
                                <span>Current Streak:</span>
                                <span>${data.statistics.current_streak ? `Digit ${data.statistics.current_streak.digit} for ${data.statistics.current_streak.length} ticks` : 'N/A'}</span>
                            </div>
                        ` : '<p>No statistics available</p>'}
                    </div>
                </div>
                
                <div class="analysis-section">
                    <h4><i class="fas fa-lightbulb"></i> Trading Suggestion</h4>
                    <div class="suggestion-box">
                        <p>Based on ML analysis, the suggested approach is:</p>
                        <div class="suggestion-action">
                            <strong>${data.analysis.recommendation}</strong>
                        </div>
                        <p class="suggestion-note">
                            <i class="fas fa-info-circle"></i>
                            Remember: This is simulated data. Real trading carries risk.
                        </p>
                    </div>
                </div>
            </div>
        `;
        
        detailedAnalysis.innerHTML = analysisHTML;
    }
    
    // Update statistics display
    function updateStatistics(stats) {
        if (!stats) return;
        
        ticksCount.textContent = stats.total_ticks;
        lastUpdate.textContent = new Date(stats.last_update).toLocaleTimeString();
        
        // Update quick stats
        const quickStatsHTML = `
            <div class="stats-grid-small">
                <div class="stat-item-small">
                    <span class="stat-label-small">Most Common:</span>
                    <span class="stat-value-small">${stats.most_common[0] ? `Digit ${stats.most_common[0][0]}` : 'N/A'}</span>
                </div>
                <div class="stat-item-small">
                    <span class="stat-label-small">Least Common:</span>
                    <span class="stat-value-small">${stats.least_common[0] ? `Digit ${stats.least_common[0][0]}` : 'N/A'}</span>
                </div>
                <div class="stat-item-small">
                    <span class="stat-label-small">Current Streak:</span>
                    <span class="stat-value-small">${stats.current_streak ? `${stats.current_streak.length}` : '0'}</span>
                </div>
                <div class="stat-item-small">
                    <span class="stat-label-small">Data Freshness:</span>
                    <span class="stat-value-small">Just now</span>
                </div>
            </div>
        `;
        
        quickStats.innerHTML = quickStatsHTML;
    }
    
    // Update data status
    function updateDataStatus(totalTicks, isTrained) {
        ticksCount.textContent = totalTicks;
        
        if (isTrained) {
            modelsStatus.textContent = 'Trained';
            modelsStatus.className = 'stat-value badge badge-success';
        } else if (totalTicks > 100) {
            modelsStatus.textContent = 'Ready to Train';
            modelsStatus.className = 'stat-value badge badge-warning';
        } else {
            modelsStatus.textContent = 'Need More Data';
            modelsStatus.className = 'stat-value badge badge-warning';
        }
    }
    
    // Update digit chart
    function updateDigitChart(stats) {
        if (!stats || !stats.digit_distribution) return;
        
        const digits = Object.keys(stats.digit_distribution);
        const frequencies = Object.values(stats.digit_distribution);
        
        const trace = {
            x: digits,
            y: frequencies,
            type: 'bar',
            marker: {
                color: frequencies.map(f => f > 12 ? '#ff006e' : f < 8 ? '#3a86ff' : '#38b000'),
                line: {
                    color: 'rgba(255,255,255,0.3)',
                    width: 1
                }
            },
            text: frequencies.map(f => f.toFixed(1) + '%'),
            textposition: 'auto',
        };
        
        const layout = {
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: 'rgba(0,0,0,0)',
            font: { color: '#fff' },
            margin: { t: 30, r: 30, b: 40, l: 40 },
            xaxis: {
                title: 'Digit',
                gridcolor: 'rgba(255,255,255,0.1)'
            },
            yaxis: {
                title: 'Frequency (%)',
                gridcolor: 'rgba(255,255,255,0.1)'
            },
            showlegend: false
        };
        
        Plotly.newPlot('digitChart', [trace], layout);
    }
    
    // Update history chart
    function updateHistoryChart(prediction) {
        // Simplified history - in real app, track more history
        const history = [prediction];
        
        const trace = {
            x: history.map((h, i) => i),
            y: history.map(h => h.ensemble.confidence * 100),
            type: 'scatter',
            mode: 'lines+markers',
            line: { color: '#3a86ff', width: 3 },
            marker: { size: 10, color: '#8338ec' }
        };
        
        const layout = {
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: 'rgba(0,0,0,0)',
            font: { color: '#fff' },
            margin: { t: 30, r: 30, b: 40, l: 40 },
            xaxis: {
                title: 'Prediction #',
                gridcolor: 'rgba(255,255,255,0.1)'
            },
            yaxis: {
                title: 'Confidence %',
                gridcolor: 'rgba(255,255,255,0.1)',
                range: [0, 100]
            },
            showlegend: false
        };
        
        Plotly.newPlot('historyChart', [trace], layout);
    }
    
    // Set status indicator
    function setStatus(status, message) {
        statusDot.className = 'status-dot ' + status;
        statusText.textContent = message;
    }
    
    // Show notification
    function showNotification(type, message) {
        // Create notification element
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.innerHTML = `
            <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'warning' ? 'exclamation-triangle' : 'times-circle'}"></i>
            <span>${message}</span>
        `;
        
        // Add to body
        document.body.appendChild(notification);
        
        // Remove after 3 seconds
        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
    
    // Socket.IO event handlers
    socket.on('connect', () => {
        setStatus('online', 'Connected to server');
        console.log('Connected to server');
    });
    
    socket.on('tick_update', (data) => {
        updateCounter++;
        liveUpdateCount.textContent = updateCounter;
        updateDataStatus(data.total_ticks, false);
    });
    
    socket.on('training_complete', (data) => {
        showNotification('success', data.message);
        modelsStatus.textContent = 'Trained';
        modelsStatus.className = 'stat-value badge badge-success';
    });
    
    socket.on('update', (data) => {
        if (data.statistics) {
            updateStatistics(data.statistics);
        }
    });
    
    // Initialize
    updateContractDescription(contractTypeSelect.value);
    setStatus('online', 'Dashboard ready');
    
    // Load initial statistics
    fetch('/api/statistics')
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                updateDataStatus(data.data_points, data.is_trained);
                if (data.statistics) {
                    updateStatistics(data.statistics);
                }
            }
        });
});